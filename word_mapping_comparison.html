<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>ISL Sentence Player (2D Canvas)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      color-scheme: light dark;
      --bg: #0f172a;
      --panel: #111b2f;
      --panel-subtle: #0c1324;
      --border: rgba(255,255,255,0.08);
      --text: #e2e8f0;
      --text-soft: #94a3b8;
      --accent: #38bdf8;
      --accent-soft: rgba(56,189,248,0.15);
      --success-soft: rgba(16,185,129,0.12);
      --warn-soft: rgba(251,191,36,0.14);
    }
    @media (prefers-color-scheme: light) {
      :root {
        --bg: #f4f7fb;
        --panel: #ffffff;
        --panel-subtle: #edf1f8;
        --border: rgba(15,23,42,0.08);
        --text: #0f172a;
        --text-soft: #475569;
        --accent-soft: rgba(37,99,235,0.12);
      }
    }

    * { box-sizing: border-box; font-family: 'Inter','Segoe UI',system-ui,-apple-system,BlinkMacSystemFont,sans-serif; }
    body {
      margin: 0; min-height: 100vh; background: var(--bg); color: var(--text);
      padding: 0; display: flex; flex-direction: column;
    }
    .app-shell { 
      width: 100%; 
      max-width: 100%; 
      display: flex; 
      flex-direction: column; 
      min-height: 100vh;
    }
    header { 
      text-align: center; 
      padding: clamp(20px,3vh,32px) clamp(16px,3vw,32px);
      background: var(--panel);
      border-bottom: 1px solid var(--border);
    }
    header h1 { margin: 0; font-size: clamp(1.8rem,3.5vw,2.5rem); color: var(--accent); }
    header p { margin: 6px 0 0; color: var(--text-soft); font-size: 0.95rem; }
    
    /* Two-column layout */
    .main-layout {
      display: grid;
      grid-template-columns: 68fr 32fr;
      flex: 1;
      gap: 0;
      min-height: 0;
    }
    
    @media (max-width: 1024px) {
      .main-layout {
        grid-template-columns: 1fr;
        grid-template-rows: auto 1fr;
      }
      .control-panel {
        order: 2;
        max-height: none !important;
      }
      .viewer-section {
        order: 1;
        min-height: 60vh;
      }
    }
    
    .viewer-section {
      background: linear-gradient(145deg, #0a0e1a, #0f1419);
      border-right: 1px solid var(--border);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: clamp(20px,3vh,40px);
      position: relative;
    }
    
    .control-panel {
      background: var(--panel);
      padding: clamp(16px,2vw,24px);
      overflow-y: auto;
      max-height: calc(100vh - 120px);
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    
    .card {
      background: linear-gradient(145deg,var(--panel-subtle),var(--panel));
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 18px;
      box-shadow: 0 8px 24px rgba(0,0,0,0.25);
    }
    
    .card-title {
      font-size: 0.85rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: var(--accent);
      margin: 0 0 14px 0;
      padding-bottom: 8px;
      border-bottom: 1px solid var(--border);
    }
    
    .row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    label { font-size: 0.75rem; text-transform: uppercase; letter-spacing: 0.15em; color: var(--text-soft); display:block; margin-bottom:6px; }
    input[type="text"] {
      width: 100%; background: rgba(0,0,0,0.2); border:1px solid var(--border);
      border-radius: 12px; padding: 12px 14px; color: var(--text); font-size: 0.95rem;
      transition:border 0.2s ease, box-shadow 0.2s ease;
    }
    input[type="text"]:focus {
      outline: none; border-color: var(--accent); box-shadow: 0 0 0 3px var(--accent-soft);
    }
    button {
      font-weight: 600; border:none; border-radius: 999px; padding:9px 16px;
      background: var(--accent); color:#041321; cursor:pointer; font-size: 0.85rem;
      box-shadow: 0 6px 16px rgba(56,189,248,0.3); transition: transform 0.2s, box-shadow 0.2s;
    }
    button:hover:not(:disabled) { transform: translateY(-1px); box-shadow:0 10px 20px rgba(56,189,248,0.4); }
    button:disabled { opacity:0.45; cursor:not-allowed; box-shadow:none; }
    #voiceBtn.live { background:#f87171; color:#000; }
    #voiceStatus { font-size:0.8rem; color:var(--text-soft); margin-top:6px; }
    .muted { color: var(--text-soft); font-size:0.85rem; }

    #glossDisplay {
      display:none; border-radius:16px; border:1px solid rgba(16,185,129,0.4);
      background: var(--success-soft); padding:14px 18px; font-family:ui-monospace,monospace;
    }
    #glossDisplay .label { font-size:0.75rem; letter-spacing:0.18em; color:rgba(16,185,129,0.9); margin-bottom:4px; }
    #warnings {display:none;border-radius:16px;border:1px solid rgba(251,191,36,0.45);background:var(--warn-soft);padding:12px 16px;color:#fcd34d;}
    #datasetPreview {display:none;border-radius:16px;border:1px solid rgba(34,197,94,0.45);background:rgba(34,197,94,0.12);padding:12px 16px;}
    #datasetPreview .label {font-size:0.7rem;text-transform:uppercase;letter-spacing:0.2em;color:rgba(34,197,94,0.9);}
    #datasetPreview .matches {display:flex;flex-wrap:wrap;gap:6px;margin-top:6px;}
    #datasetPreview .match-item {padding:4px 10px;border-radius:999px;background:rgba(34,197,94,0.18);border:1px solid rgba(34,197,94,0.4);font-size:0.75rem;}

    .semantic-panel {
      display:none;
      border-radius:12px;
      border:1px solid rgba(234,179,8,0.35);
      background:rgba(234,179,8,0.1);
      padding:10px 12px;
      font-size:0.8rem;
      margin-top:8px;
    }
    .semantic-panel .label {
      font-size:0.65rem;
      text-transform:uppercase;
      letter-spacing:0.2em;
      color:rgba(234,179,8,0.9);
    }

    /* 3D Viewer */
    .viewer-container {
      width: 100%;
      max-width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .viewWrap {
      position:relative;
      display:block;
      width: 100%;
      max-width: 1200px;
      aspect-ratio: 16 / 9;
      border-radius: 16px;
      overflow: hidden;
      box-shadow: 0 20px 60px rgba(0,0,0,0.5);
      border: 1px solid rgba(255,255,255,0.05);
      background: linear-gradient(135deg, rgba(15,23,42,0.95), rgba(30,41,59,0.9));
    }
    
    .viewWrap canvas {
      display: block;
      width: 100%;
      height: 100%;
      object-fit: contain;
    }
    
    .viewBadge {
      position:absolute;
      top:16px;
      left:16px;
      background:rgba(56,189,248,0.85);
      backdrop-filter: blur(8px);
      color:#000;
      padding:6px 14px;
      border-radius:999px;
      font-size:0.7rem;
      font-weight: 700;
      letter-spacing:0.2em;
      z-index: 10;
    }
    
    #status {
      position: absolute;
      bottom: 16px;
      left: 16px;
      background: rgba(0,0,0,0.65);
      backdrop-filter: blur(8px);
      color: var(--text-soft);
      padding: 8px 14px;
      border-radius: 8px;
      font-size: 0.75rem;
      font-family: ui-monospace, monospace;
      z-index: 10;
    }

    /* Control sections */
    .control-section {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    
    .control-section label.inline {
      display: flex;
      align-items: center;
      gap: 8px;
      margin: 0;
    }
    
    .control-section input[type="checkbox"] {
      width: auto;
    }
    
    .hud {
      font:11px ui-monospace,monospace;
      background:rgba(0,0,0,0.25);
      border:1px dashed var(--border);
      padding:10px;
      border-radius:10px;
      white-space:pre-wrap;
      color:var(--text-soft);
    }
    
    .swatch {
      width:18px;
      height:18px;
      border-radius:50%;
      border:1px solid var(--border);
    }
    
    input[type="range"] {
      width: 100%;
      height: 6px;
      border-radius: 3px;
      background: rgba(255,255,255,0.1);
      outline: none;
      -webkit-appearance: none;
      appearance: none;
    }
    
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: var(--accent);
      cursor: pointer;
      box-shadow: 0 2px 8px rgba(56,189,248,0.4);
    }
    
    input[type="range"]::-moz-range-thumb {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: var(--accent);
      cursor: pointer;
      border: none;
      box-shadow: 0 2px 8px rgba(56,189,248,0.4);
    }
    
    input[type="color"] {
      width: 50px;
      height: 32px;
      border: 1px solid var(--border);
      border-radius: 8px;
      cursor: pointer;
      background: transparent;
    }
  </style>
</head>
<body>
  <div class="app-shell">
    <header>
      <h1>ISL Translator</h1>
      <p>Indian Sign Language Translation &amp; Real World Emulation</p>
    </header>

    <div class="main-layout">
      <!-- LEFT: 3D Viewer Section (65-70%) -->
      <div class="viewer-section">
        <div class="viewer-container">
          <div class="viewWrap" id="threeView">
            <div class="viewBadge">3D</div>
          </div>
        </div>
        <div id="status" class="muted">Status: idle</div>
      </div>

      <!-- RIGHT: Control Panel (30-35%) -->
      <div class="control-panel">
        
        <!-- Sentence Input Card -->
        <div class="card">
          <h3 class="card-title">Sentence Translation</h3>
          <div class="control-section">
            <label for="sentenceInput">Enter Text</label>
            <input id="sentenceInput" type="text" placeholder="Type a word or phraseâ€¦">
            <div class="row">
              <button id="convertBtn">Convert</button>
              <button id="voiceBtn" type="button">ðŸŽ™ Speak</button>
            </div>
            <div id="voiceStatus">Voice: checking supportâ€¦</div>
            <div id="datasetPreview">
              <div class="label">Available in dataset:</div>
              <div class="matches" id="datasetMatches"></div>
            </div>
            <div id="glossDisplay">
              <div class="label">ISL Gloss</div>
              <div class="glosses" id="glosses"></div>
            </div>
            <div id="warnings"></div>
            <div id="semanticPanel" class="semantic-panel">
              <div class="label">Semantic matches (toggle to keep/remove):</div>
              <div id="semanticMatches"></div>
            </div>
          </div>
        </div>

        <!-- Sentence Playback Card -->
        <div class="card">
          <h3 class="card-title">Sentence Playback</h3>
          <div class="control-section">
            <div class="row">
              <button id="playSentence" disabled>Play Sentence</button>
              <button id="stopSentence" disabled>Stop</button>
            </div>
            <label class="inline"><input type="checkbox" id="loopSentence"> Loop playback</label>
            <span id="sentenceProgress" class="muted"></span>
          </div>
        </div>

        <!-- Render Options Card -->
        <div class="card">
          <h3 class="card-title">Render Options</h3>
          <div class="control-section">
            <div class="row">
              <label class="inline"><input type="checkbox" id="flipY"> Flip Y</label>
              <label class="inline"><input type="checkbox" id="autofit" checked> Auto-fit</label>
              <label class="inline"><input type="checkbox" id="showBBox"> Show bbox</label>
            </div>
            
            <label>Zoom <span id="zoom3dVal" class="muted">1.0x</span></label>
            <input type="range" id="zoom3d" min="0.5" max="2" step="0.05" value="1">
            
            <label>Point size <span id="ptSizeVal" class="muted">4</span></label>
            <input type="range" id="ptSize" min="1" max="8" step="0.5" value="4">
            
            <label>Point color</label>
            <div class="row">
              <input type="color" id="ptColor" value="#ff1a1a">
              <span class="swatch" id="ptSwatch" style="background:#ff1a1a"></span>
            </div>
            
            <label>Edge color</label>
            <div class="row">
              <input type="color" id="edgeColor" value="#00a3ff">
              <span class="swatch" id="edgeSwatch" style="background:#00a3ff"></span>
            </div>
            
            <div class="hud" id="hud"></div>
          </div>
        </div>

      </div>
    </div>
  </div>

  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
  <script>
    // ---------- MediaPipe Skeleton Definitions ----------
    // Pose landmark indices
    const POSE = { 
      L_SHOULDER: 11, R_SHOULDER: 12, 
      L_ELBOW: 13, R_ELBOW: 14, 
      L_WRIST: 15, R_WRIST: 16, 
      L_HIP: 23, R_HIP: 24, 
      L_KNEE: 25, R_KNEE: 26, 
      L_ANKLE: 27, R_ANKLE: 28,
      NOSE: 0, L_EYE: 2, R_EYE: 5, L_EAR: 7, R_EAR: 8,
      MOUTH_LEFT: 9, MOUTH_RIGHT: 10
    };
    
    // Custom anatomical pose connections (same-side only, human-like)
    // Uses MediaPipe Pose indices via POSE constants.
    const CUSTOM_EDGES = [
      // Head (facial anchors)
      [POSE.NOSE, POSE.L_EYE], [POSE.L_EYE, POSE.L_EAR],
      [POSE.NOSE, POSE.R_EYE], [POSE.R_EYE, POSE.R_EAR],
      // Clavicle
      [POSE.L_SHOULDER, POSE.R_SHOULDER],
      // Torso to hips
      [POSE.L_SHOULDER, POSE.L_HIP], [POSE.R_SHOULDER, POSE.R_HIP],
      [POSE.L_HIP, POSE.R_HIP],
      // Left arm chain
      [POSE.L_SHOULDER, POSE.L_ELBOW], [POSE.L_ELBOW, POSE.L_WRIST],
      // Left wrist to pose finger tips (thumb/index/pinky proxies)
      [POSE.L_WRIST, 21], [POSE.L_WRIST, 19], [POSE.L_WRIST, 17],
      // Right arm chain
      [POSE.R_SHOULDER, POSE.R_ELBOW], [POSE.R_ELBOW, POSE.R_WRIST],
      // Right wrist to pose finger tips (thumb/index/pinky proxies)
      [POSE.R_WRIST, 22], [POSE.R_WRIST, 20], [POSE.R_WRIST, 18],
      // Legs
      [POSE.L_HIP, POSE.L_KNEE], [POSE.L_KNEE, POSE.L_ANKLE], [POSE.L_ANKLE, 29],
      [POSE.R_HIP, POSE.R_KNEE], [POSE.R_KNEE, POSE.R_ANKLE], [POSE.R_ANKLE, 30]
    ];
    
    // Landmark offsets in MediaPipe output (pose=0-32, left_hand=33-53, right_hand=54-74)
    const LH_OFFSET = 33;
    const RH_OFFSET = 54;
    
    // Build complete skeleton edges
    function buildSkeletonEdges(numPoints) {
      // Only use custom pose edges; ignore full hand skeletons to avoid cross-hand links.
      const valid = CUSTOM_EDGES.filter(([a, b]) => a < numPoints && b < numPoints);
      
      // Remove any cross-hand links (left hand indices â†” right hand indices)
      // and remove any direct wrist-to-wrist line if present
      const isLeftHand = (i) => i >= LH_OFFSET && i < RH_OFFSET;
      const isRightHand = (i) => i >= RH_OFFSET;
      return valid.filter(([a, b]) => {
        // no left-hand to right-hand direct connections
        if ((isLeftHand(a) && isRightHand(b)) || (isLeftHand(b) && isRightHand(a))) return false;
        // no direct L_WRIST â†” R_WRIST
        if ((a === POSE.L_WRIST && b === POSE.R_WRIST) || (a === POSE.R_WRIST && b === POSE.L_WRIST)) return false;
        return true;
      });
    }

    // ---------- ISL Dataset & Grammar Constants ----------
    const AVAILABLE_WORDS = [
      'alright', 'beautiful', 'bed', 'bedroom', 'blind', 'cell phone', 'chair', 
      'clock', 'computer', 'deaf', 'door', 'dream', 'dress', 'fan', 'friday',
      'good afternoon', 'good morning', 'happy', 'hat', 'hello', 'how are you',
      'lamp', 'loud', 'monday', 'quiet', 'sad', 'saturday', 'shirt', 'skirt',
      'suit', 'sunday', 'table', 'thursday', 'today', 'tuesday', 'ugly',
      'wednesday', 'window'
    ];

    const WORD_TO_FILENAME = {
      'alright': 'Alright', 'beautiful': 'Beautiful', 'bed': 'Bed', 'bedroom': 'Bedroom',
      'blind': 'Blind', 'cell phone': 'Cell phone', 'chair': 'Chair', 'clock': 'Clock',
      'computer': 'Computer', 'deaf': 'Deaf', 'door': 'Door', 'dream': 'Dream',
      'dress': 'Dress', 'fan': 'Fan', 'friday': 'Friday', 'good afternoon': 'Good afternoon',
      'good morning': 'Good Morning', 'happy': 'happy', 'hat': 'Hat', 'hello': 'Hello',
      'how are you': 'How are you', 'lamp': 'Lamp', 'loud': 'loud', 'monday': 'Monday',
      'quiet': 'quiet', 'sad': 'sad', 'saturday': 'Saturday', 'shirt': 'Shirt',
      'skirt': 'Skirt', 'suit': 'Suit', 'sunday': 'Sunday', 'table': 'Table',
      'thursday': 'Thursday', 'today': 'Today', 'tuesday': 'Tuesday', 'ugly': 'Ugly',
      'wednesday': 'Wednesday', 'window': 'Window'
    };

    const MULTI_WORD_SIGNS = {
      'cell phone': 'cell phone',
      'good afternoon': 'good afternoon',
      'good morning': 'good morning',
      'how are you': 'how are you'
    };

    const TIME_WORDS = new Set([
      'today', 'tomorrow', 'yesterday', 'monday', 'tuesday', 'wednesday',
      'thursday', 'friday', 'saturday', 'sunday'
    ]);

    const FUNCTION_WORDS = new Set([
      'a', 'an', 'the', 'is', 'am', 'are', 'was', 'were', 'be', 'been',
      'will', 'would', 'can', 'could', 'should', 'shall', 'may', 'might',
      'to', 'at', 'in', 'on', 'of', 'for', 'with', 'from', 'by', 'about',
      'i', 'you', 'he', 'she', 'it', 'we', 'they', 'me', 'him', 'her',
      'us', 'them', 'my', 'your', 'our', 'their', 'mine', 'yours', 'ours', 'theirs', 'its'
    ]);

    const SEMANTIC_ALIASES = {
      'alright': ['okay', 'ok', 'fine'],
      'beautiful': ['pretty', 'gorgeous', 'lovely'],
      'bed': ['bunk', 'cot'],
      'bedroom': ['bed room', 'room', 'sleeping room'],
      'blind': ['visionless', 'sightless', 'visually impaired', 'vision impaired'],
      'cell phone': ['mobile phone', 'mobile', 'phone', 'smartphone', 'cellphone'],
      'chair': ['seat', 'stool', 'armchair'],
      'clock': ['watch', 'timepiece'],
      'computer': ['pc', 'laptop', 'desktop', 'computer system'],
      'deaf': ['hearing impaired', 'hard of hearing'],
      'door': ['gate', 'entryway'],
      'dream': ['vision', 'fantasy', 'imagine'],
      'dress': ['gown', 'frock'],
      'fan': ['cooler', 'blower', 'ceiling fan'],
      'friday': ['fri'],
      'good afternoon': ['afternoon greeting', 'good noon'],
      'good morning': ['morning greeting', 'gm', 'good day'],
      'happy': ['glad', 'joyful', 'cheerful', 'pleased'],
      'hat': ['cap', 'beanie'],
      'hello': ['hi', 'hey', 'greetings'],
      'how are you': ['how r u', 'how are ya', 'how you doing'],
      'lamp': ['light', 'lantern'],
      'loud': ['noisy', 'booming'],
      'monday': ['mon'],
      'quiet': ['silent', 'hushed', 'calm'],
      'sad': ['unhappy', 'upset', 'sorrowful'],
      'saturday': ['sat'],
      'shirt': ['top', 'tshirt', 't-shirt', 'tee'],
      'skirt': ['mini', 'skirts', 'pleated skirt'],
      'suit': ['blazer', 'tuxedo', 'coat and pants'],
      'sunday': ['sun'],
      'table': ['desk', 'dining table'],
      'thursday': ['thu'],
      'today': ['present day', 'nowadays'],
      'tuesday': ['tue'],
      'ugly': ['unattractive', 'plain'],
      'wednesday': ['wed'],
      'window': ['pane', 'glass window']
    };

    const LEMMA_OVERRIDES = {
      'better': 'good',
      'best': 'good',
      'worse': 'bad',
      'worst': 'bad',
      'happier': 'happy',
      'happiest': 'happy',
      'sadder': 'sad',
      'saddest': 'sad',
      'children': 'child',
      'men': 'man',
      'women': 'woman',
      'people': 'person',
      'phones': 'phone',
      'cellphones': 'cellphone'
    };

    const LEMMA_SUFFIX_RULES = [
      { suffix: 'ies', replacement: 'y', min: 4 },
      { suffix: 'ves', replacement: 'f', min: 4 },
      { suffix: 'ing', replacement: '', min: 5 },
      { suffix: 'ed', replacement: '', min: 4 },
      { suffix: 'est', replacement: '', min: 5 },
      { suffix: 'er', replacement: '', min: 4 },
      { suffix: 's', replacement: '', min: 4, skipDouble: true }
    ];

    const AVAILABLE_WORD_SET = new Set(AVAILABLE_WORDS);
    const ALIAS_TO_CANONICAL = buildAliasMap(SEMANTIC_ALIASES);
    const RECOGNIZED_PHRASES = [...new Set([...AVAILABLE_WORDS, ...Object.keys(ALIAS_TO_CANONICAL)])];

    const SEMANTIC_CATEGORY_KEYWORDS = {
      greeting: ['hello', 'hi', 'hey', 'good morning', 'good afternoon', 'how are you'],
      time: ['today', 'tomorrow', 'yesterday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'],
      clothing: ['hat', 'dress', 'shirt', 'skirt', 'suit'],
      furniture: ['bed', 'bedroom', 'chair', 'table'],
      device: ['computer', 'cell', 'phone', 'fan', 'lamp'],
      feeling_pos: ['happy', 'alright', 'beautiful', 'good'],
      feeling_neg: ['sad', 'ugly', 'loud', 'quiet'],
      household: ['door', 'window', 'lamp'],
      accessibility: ['blind', 'deaf'],
      imagination: ['dream']
    };

    const SEMANTIC_CATEGORY_LIST = Object.keys(SEMANTIC_CATEGORY_KEYWORDS);
    const LOCAL_EMBED_DIM = 64;
    const LOCAL_EMBED_EXTRA = SEMANTIC_CATEGORY_LIST.length + 2;
    const LOCAL_EMBED_HASH_SPACE = Math.max(16, LOCAL_EMBED_DIM - LOCAL_EMBED_EXTRA);

    const SEMANTIC_MATCH_SETTINGS = {
      minSimilarity: 0.85,
      endpoint: window.ISL_EMBEDDING_ENDPOINT || null,
      apiKey: window.ISL_EMBEDDING_API_KEY || null
    };

    const semanticIndexState = {
      method: SEMANTIC_MATCH_SETTINGS.endpoint ? 'remote' : 'local',
      ready: false,
      entries: [],
      dimension: LOCAL_EMBED_DIM,
      loading: null
    };

    const EMBEDDING_CACHE = new Map();
    let lastConversion = null;

    const VoiceRecognitionCtor = window.SpeechRecognition || window.webkitSpeechRecognition || null;
    const voiceCapture = {
      supported: !!VoiceRecognitionCtor,
      recognition: null,
      listening: false,
      finalTranscript: '',
      interimTranscript: ''
    };

    function buildAliasMap(table) {
      const map = {};
      Object.entries(table).forEach(([canonical, variants]) => {
        const key = (canonical || '').trim().toLowerCase();
        if (key) map[key] = canonical;
        if (!Array.isArray(variants)) return;
        variants.forEach(variant => {
          const aliasKey = (variant || '').trim().toLowerCase();
          if (aliasKey) map[aliasKey] = canonical;
        });
      });
      return map;
    }

    function lemmatizeWord(word) {
      if (!word) return '';
      const lower = word.toLowerCase();
      if (LEMMA_OVERRIDES[lower]) return LEMMA_OVERRIDES[lower];
      for (const rule of LEMMA_SUFFIX_RULES) {
        if (!lower.endsWith(rule.suffix)) continue;
        if (lower.length <= (rule.min || 0)) continue;
        if (rule.skipDouble && lower.endsWith(rule.suffix + rule.suffix[rule.suffix.length - 1])) continue;
        if (rule.suffix === 's' && lower.endsWith('ss')) continue;
        const stem = lower.slice(0, lower.length - rule.suffix.length) + (rule.replacement || '');
        if (stem.length >= 2) return stem;
      }
      return lower;
    }

    function resolveCanonicalPhrase(candidate, candidateLemma) {
      if (AVAILABLE_WORD_SET.has(candidate)) return { canonical: candidate, source: 'exact' };
      if (candidateLemma && AVAILABLE_WORD_SET.has(candidateLemma)) return { canonical: candidateLemma, source: 'lemma' };
      if (ALIAS_TO_CANONICAL[candidate]) return { canonical: ALIAS_TO_CANONICAL[candidate], source: 'alias' };
      if (candidateLemma && ALIAS_TO_CANONICAL[candidateLemma]) return { canonical: ALIAS_TO_CANONICAL[candidateLemma], source: 'alias' };
      return null;
    }

    function isTimePhrase(phrase) {
      return phrase.split(' ').some(word => TIME_WORDS.has(word));
    }

    function buildGlossSequence(tokens) {
      const accepted = tokens.filter(t => (t.kind === 'match' || t.kind === 'semantic') && t.accepted !== false);
      const timeFirst = [];
      const others = [];
      accepted.forEach(token => {
        (isTimePhrase(token.canonical) ? timeFirst : others).push(token);
      });
      return [...timeFirst, ...others].map(token => token.canonical);
    }

    function hashString(str) {
      let hash = 0;
      for (let i = 0; i < str.length; i++) {
        hash = (hash * 31 + str.charCodeAt(i)) >>> 0;
      }
      return hash;
    }

    function detectCategoryActivations(text) {
      const activations = new Array(SEMANTIC_CATEGORY_LIST.length).fill(0);
      SEMANTIC_CATEGORY_LIST.forEach((name, idx) => {
        const keywords = SEMANTIC_CATEGORY_KEYWORDS[name];
        if (!keywords) return;
        for (const kw of keywords) {
          if (text.includes(kw)) {
            activations[idx] = 1;
            break;
          }
        }
      });
      return activations;
    }

    function localSimpleEmbedding(text) {
      const cleaned = (text || '').toLowerCase().trim();
      const vec = new Float32Array(LOCAL_EMBED_DIM);
      if (!cleaned) return vec;

      for (let i = 0; i < cleaned.length; i++) {
        const code = cleaned.charCodeAt(i);
        const idx = (code + i) % LOCAL_EMBED_HASH_SPACE;
        vec[idx] += 1;
        if (i < cleaned.length - 2) {
          const trigram = cleaned.slice(i, i + 3);
          const triIdx = hashString(trigram) % LOCAL_EMBED_HASH_SPACE;
          vec[triIdx] += 0.5;
        }
      }

      vec[LOCAL_EMBED_HASH_SPACE] = Math.min(3, cleaned.length / 4);
      vec[LOCAL_EMBED_HASH_SPACE + 1] = (cleaned.match(/[aeiou]/g) || []).length;

      const categories = detectCategoryActivations(cleaned);
      categories.forEach((value, idx) => {
        const target = LOCAL_EMBED_DIM - categories.length + idx;
        vec[target] = value;
      });

      return vec;
    }

    function vectorNorm(vec) {
      if (!vec) return 0;
      let sum = 0;
      for (let i = 0; i < vec.length; i++) {
        sum += vec[i] * vec[i];
      }
      return Math.sqrt(sum);
    }

    function cosineSimilarity(vecA, vecB, normA, normB) {
      if (!vecA || !vecB || !normA || !normB) return 0;
      const len = Math.min(vecA.length, vecB.length);
      let dot = 0;
      for (let i = 0; i < len; i++) {
        dot += vecA[i] * vecB[i];
      }
      return dot / (normA * normB);
    }

    async function ensureSemanticIndexReady() {
      if (semanticIndexState.ready) return semanticIndexState;
      if (!semanticIndexState.loading) {
        semanticIndexState.loading = loadSemanticIndex();
      }
      return semanticIndexState.loading;
    }

    async function loadSemanticIndex() {
      if (SEMANTIC_MATCH_SETTINGS.endpoint) {
        const remoteEntries = await buildIndexWithEndpoint();
        if (remoteEntries.length) {
          semanticIndexState.method = 'remote';
          semanticIndexState.entries = remoteEntries;
          semanticIndexState.dimension = remoteEntries[0].vector.length;
          semanticIndexState.ready = true;
          return semanticIndexState;
        }
      }
      semanticIndexState.method = 'local';
      semanticIndexState.entries = generateLocalSemanticIndex();
      semanticIndexState.dimension = LOCAL_EMBED_DIM;
      semanticIndexState.ready = true;
      return semanticIndexState;
    }

    function wordTokenCount(text) {
      return (text || '').trim().split(/\s+/).filter(Boolean).length || 1;
    }

    function generateLocalSemanticIndex() {
      return AVAILABLE_WORDS.map(word => {
        const vector = localSimpleEmbedding(word);
        return { word, vector, norm: vectorNorm(vector), tokens: wordTokenCount(word) };
      });
    }

    async function buildIndexWithEndpoint() {
      const entries = [];
      for (const word of AVAILABLE_WORDS) {
        const vector = await fetchEmbeddingFromEndpoint(word);
        if (!vector) {
          return [];
        }
        entries.push({ word, vector, norm: vectorNorm(vector), tokens: wordTokenCount(word) });
      }
      return entries;
    }

    async function fetchEmbeddingFromEndpoint(text) {
      try {
        const headers = { 'Content-Type': 'application/json' };
        if (SEMANTIC_MATCH_SETTINGS.apiKey) {
          headers['Authorization'] = `Bearer ${SEMANTIC_MATCH_SETTINGS.apiKey}`;
        }
        const res = await fetch(SEMANTIC_MATCH_SETTINGS.endpoint, {
          method: 'POST',
          headers,
          body: JSON.stringify({ text })
        });
        if (!res.ok) return null;
        const data = await res.json();
        if (Array.isArray(data.vector)) {
          return Float32Array.from(data.vector.map(Number));
        }
      } catch (err) {
        console.warn('Embedding endpoint error:', err);
      }
      return null;
    }

    async function embedText(text) {
      const key = (text || '').toLowerCase();
      if (EMBEDDING_CACHE.has(key)) return EMBEDDING_CACHE.get(key);

      let vector = null;
      if (semanticIndexState.method === 'remote' && SEMANTIC_MATCH_SETTINGS.endpoint) {
        vector = await fetchEmbeddingFromEndpoint(text);
        if (!vector) return null;
      } else {
        vector = localSimpleEmbedding(text);
      }
      EMBEDDING_CACHE.set(key, vector);
      return vector;
    }

    async function findSemanticFallbackForToken(token) {
      await ensureSemanticIndexReady();
      if (!semanticIndexState.entries.length) return null;
      const query = token.lemma || token.normalized || token.original;
      const vector = await embedText(query);
      if (!vector) return null;
      const norm = vectorNorm(vector);
      if (!norm) return null;
      const tokenLength = wordTokenCount(token.original || token.lemma || token.normalized);
      let best = null;
      for (const entry of semanticIndexState.entries) {
        if (entry.tokens && entry.tokens !== tokenLength) continue;
        if (!entry.norm || !entry.vector) continue;
        const score = cosineSimilarity(vector, entry.vector, norm, entry.norm);
        if (!best || score > best.score) {
          best = { word: entry.word, score };
        }
      }
      if (best && best.score >= SEMANTIC_MATCH_SETTINGS.minSimilarity) {
        return best;
      }
      return null;
    }

    async function applySemanticFallback(tokens) {
      const applied = [];
      const needsFallback = tokens.some(t => t.kind === 'raw');
      if (!needsFallback) return applied;

      await ensureSemanticIndexReady();
      for (let i = 0; i < tokens.length; i++) {
        const token = tokens[i];
        if (token.kind !== 'raw') continue;
        const fallback = await findSemanticFallbackForToken(token);
        if (fallback) {
          token.kind = 'semantic';
          token.canonical = fallback.word;
          token.source = 'semantic';
          token.score = fallback.score;
          token.accepted = true;
          applied.push({ index: i, original: token.original, canonical: fallback.word, score: fallback.score });
        }
      }
      return applied;
    }

    function getUnmatchedWords(tokens) {
      return tokens.filter(t => t.kind === 'raw').map(t => t.original.toLowerCase());
    }

    // ---------- ISL Grammar Conversion (Longest-Match-First Algorithm) ----------
    async function convertSentenceToGloss(sentence) {
      const original = sentence.trim();
      if (!original) return { tokens: [], semanticApplied: [], currentGlosses: [] };

      const cleaned = original
        .replace(/[.,!?;:]/g, '')
        .replace(/['â€™"]/g, '')
        .replace(/[-/]/g, ' ')
        .replace(/\s+/g, ' ')
        .trim();
      if (!cleaned) return { tokens: [], semanticApplied: [], currentGlosses: [] };

      const rawWords = cleaned.split(' ');
      const normalizedWords = rawWords.map(w => w.toLowerCase());
      const lemmaWords = normalizedWords.map(lemmatizeWord);

      const tokens = [];
      let position = 0;
      
      const maxLen = normalizedWords.length;

      while (position < maxLen) {
        let foundMatch = false;
        for (let len = maxLen - position; len >= 1; len--) {
          const spanNormalized = normalizedWords.slice(position, position + len).join(' ');
          const spanLemma = lemmaWords.slice(position, position + len).join(' ');
          const resolved = resolveCanonicalPhrase(spanNormalized, spanLemma);
          if (resolved) {
            tokens.push({
              kind: 'match',
              canonical: resolved.canonical,
              source: resolved.source,
              original: rawWords.slice(position, position + len).join(' '),
              accepted: true
            });
            position += len;
            foundMatch = true;
            break;
          }
        }
        
        if (!foundMatch) {
          const currentWord = normalizedWords[position];
          if (!FUNCTION_WORDS.has(currentWord)) {
            tokens.push({
              kind: 'raw',
              original: rawWords[position],
              normalized: currentWord,
              lemma: lemmaWords[position],
              accepted: false
            });
          }
          position++;
        }
      }
      
      const semanticApplied = await applySemanticFallback(tokens);
      const currentGlosses = buildGlossSequence(tokens);

      return { tokens, semanticApplied, currentGlosses };
    }

    // ---------- Real-time Dataset Preview ----------
    function showDatasetPreview(sentence) {
      const previewEl = document.getElementById('datasetPreview');
      const matchesEl = document.getElementById('datasetMatches');
      
      if (!sentence || sentence.trim().length === 0) {
        previewEl.style.display = 'none';
        return;
      }
      
      const text = sentence.toLowerCase().replace(/[.,!?;:]/g, '');
      const words = text.split(/\s+/).filter(w => w.length > 0);
      
      if (words.length === 0) {
        previewEl.style.display = 'none';
        return;
      }
      
      // Find all possible matches in dataset (longest first)
      const matches = new Set();
      const allPhrases = [...RECOGNIZED_PHRASES].sort((a, b) => b.split(' ').length - a.split(' ').length);
      
      for (const phrase of allPhrases) {
        const phraseWords = phrase.split(' ');
        // Check if this phrase appears in the sentence
        for (let i = 0; i <= words.length - phraseWords.length; i++) {
          const candidate = words.slice(i, i + phraseWords.length).join(' ');
          if (candidate === phrase) {
            const canonical = AVAILABLE_WORD_SET.has(phrase) ? phrase : (ALIAS_TO_CANONICAL[phrase] || phrase);
            matches.add(canonical);
          }
        }
      }
      
      if (matches.size > 0) {
        const matchItems = Array.from(matches)
          .map(m => `<span class="match-item">${m.toUpperCase()}</span>`)
          .join('');
        matchesEl.innerHTML = matchItems;
        previewEl.style.display = 'block';
      } else {
        matchesEl.innerHTML = '<span class="no-matches">No matching words in dataset</span>';
        previewEl.style.display = 'block';
      }
    }

    // ---------- Player state ----------
    let frames = null, fps = 30, raf = null, startTime = 0, frameIndex = 0, pausedAt = 0, playing = false;
    
    // Sentence playback state
    let sentenceMode = {
      active: false,
      glosses: [],
      currentIndex: 0,
      loop: false
    };

    const sentenceInputEl = document.getElementById('sentenceInput');
    const convertBtn = document.getElementById('convertBtn');
    const voiceBtn = document.getElementById('voiceBtn');
    const voiceStatusEl = document.getElementById('voiceStatus');
    const wordEl = document.getElementById('word');
    const statusEl = document.getElementById('status');
    const btnLoad = document.getElementById('load');
    const btnPlayPause = document.getElementById('playPause');
    const btnStop = document.getElementById('stop');
    const btnStep = document.getElementById('step');
    const hudEl = document.getElementById('hud');

    const canvas = document.createElement('canvas');
    canvas.width = 960;
    canvas.height = 540;
    const ctx = canvas.getContext('2d');

    function getThreeViewSize() {
      const container = document.getElementById('threeView');
      if (!container) return { width: 960, height: 540 };
      const rect = container.getBoundingClientRect();
      const width = Math.max(320, Math.floor(rect.width || container.clientWidth || 960));
      const height = Math.max(240, Math.floor(rect.height || container.clientHeight || width * (9 / 16)));
      return { width, height };
    }

    function syncCanvasSize() {
      const { width, height } = getThreeViewSize();
      canvas.width = width;
      canvas.height = height;
      return { width, height };
    }

    // Render controls
    const flipYEl = document.getElementById('flipY');
    const autofitEl = document.getElementById('autofit');
    const showBBoxEl = document.getElementById('showBBox');
    const ptSizeEl = document.getElementById('ptSize');
    const ptSizeValEl = document.getElementById('ptSizeVal');
    const ptColorEl = document.getElementById('ptColor');
    const edgeColorEl = document.getElementById('edgeColor');
    const ptSwatch = document.getElementById('ptSwatch');
    const edgeSwatch = document.getElementById('edgeSwatch');
    const zoom3dEl = document.getElementById('zoom3d');
    const zoom3dValEl = document.getElementById('zoom3dVal');

    // ---------- UI helpers ----------
    function setStatus(text) { statusEl.textContent = 'Status: ' + text; }
    function enableControls(ready) {
      btnPlayPause.disabled = !ready;
      btnStop.disabled = !ready;
      btnStep.disabled = !ready;
    }
    function updateHud(extra='') {
      const len = Array.isArray(frames) ? frames.length : 0;
      hudEl.textContent =
`frames: ${len}
fps: ${fps}
frameIndex: ${frameIndex}${extra ? '\n'+extra : ''}`;
    }
    function rerenderCurrentFrame() {
      if (!frames || !frames.length) return;
      const idx = Math.min(frameIndex, frames.length - 1);
      const frame = frames[idx];
      if (!frame) return;
      try {
        window.applyCanonicalFrame(frame, idx);
      } catch (err) {
        console.warn('Failed to rerender frame', err);
      }
    }
    function updateZoomDisplay() {
      if (!zoom3dEl || !zoom3dValEl) return;
      const value = Number(zoom3dEl.value) || 1;
      zoom3dValEl.textContent = value.toFixed(1) + 'x';
    }
    function setVoiceStatus(text) {
      if (voiceStatusEl) voiceStatusEl.textContent = 'Voice: ' + text;
    }

    function renderWarnings(conversion) {
      const warningsEl = document.getElementById('warnings');
      if (!warningsEl) return;
      if (!conversion) {
        warningsEl.textContent = '';
        warningsEl.classList.remove('show');
        return;
      }

      const unmatched = getUnmatchedWords(conversion.tokens);
      const droppedSemantic = conversion.tokens
        .filter(token => token.kind === 'semantic' && token.accepted === false)
        .map(token => token.original.toLowerCase());
      const activeSemantic = conversion.tokens
        .filter(token => token.kind === 'semantic' && token.accepted !== false);

      const messages = [];
      const skipped = [...unmatched, ...droppedSemantic];
      if (skipped.length) {
        messages.push(`Words not in dataset (skipped): ${skipped.join(', ')}`);
      }
      if (activeSemantic.length) {
        const detail = activeSemantic
          .map(token => `${token.original.toLowerCase()}â†’${token.canonical.toUpperCase()} (${(token.score || 0).toFixed(2)})`)
          .join(', ');
        messages.push(`Semantic fallback applied: ${detail}`);
      }

      if (messages.length) {
        warningsEl.textContent = messages.join(' | ');
        warningsEl.classList.add('show');
      } else {
        warningsEl.textContent = '';
        warningsEl.classList.remove('show');
      }
    }

    function renderSemanticPanel(conversion) {
      const panel = document.getElementById('semanticPanel');
      const listEl = document.getElementById('semanticMatches');
      if (!panel || !listEl) return;
      if (!conversion) {
        panel.style.display = 'none';
        listEl.innerHTML = '';
        return;
      }

      const semanticTokens = conversion.tokens
        .map((token, index) => ({ token, index }))
        .filter(item => item.token.kind === 'semantic');

      if (!semanticTokens.length) {
        panel.style.display = 'none';
        listEl.innerHTML = '';
        return;
      }

      panel.style.display = 'block';
      const markup = semanticTokens.map(({ token, index }) => {
        const score = (token.score || 0).toFixed(2);
        const checked = token.accepted === false ? '' : 'checked';
        return `<label class="semantic-match">
          <input type="checkbox" class="semantic-toggle" data-token="${index}" ${checked}>
          <span>${token.original} â†’ ${token.canonical.toUpperCase()} (${score})</span>
        </label>`;
      }).join('');
      listEl.innerHTML = markup;
    }

    function refreshConversionViews() {
      const glossDisplay = document.getElementById('glossDisplay');
      const glossText = document.getElementById('glosses');
      const playBtn = document.getElementById('playSentence');

      if (!lastConversion) {
        glossDisplay.style.display = 'none';
        glossText.textContent = '';
        if (playBtn) {
          playBtn.disabled = true;
          playBtn.dataset.glosses = '[]';
        }
        renderWarnings(null);
        renderSemanticPanel(null);
        return;
      }

      lastConversion.currentGlosses = buildGlossSequence(lastConversion.tokens);
      const glosses = lastConversion.currentGlosses;

      if (glosses.length) {
        glossText.textContent = glosses.map(g => g.toUpperCase()).join(' â†’ ');
        glossDisplay.style.display = 'block';
        playBtn.disabled = false;
        playBtn.dataset.glosses = JSON.stringify(glosses);
        setStatus(`Converted to ${glosses.length} signs`);
      } else {
        glossText.textContent = '';
        glossDisplay.style.display = 'none';
        playBtn.disabled = true;
        playBtn.dataset.glosses = '[]';
        setStatus('No valid words found in sentence');
      }

      renderWarnings(lastConversion);
      renderSemanticPanel(lastConversion);
    }

    async function runSentenceConversion(sentence) {
      if (!convertBtn) return;
      convertBtn.disabled = true;
      setStatus('Converting sentence â€¦');
      const panel = document.getElementById('semanticPanel');
      if (panel) panel.style.display = 'none';
      try {
        lastConversion = await convertSentenceToGloss(sentence);
        refreshConversionViews();
      } catch (err) {
        console.error('Sentence conversion failed:', err);
        setStatus('Conversion failed');
        lastConversion = null;
        refreshConversionViews();
      } finally {
        convertBtn.disabled = false;
      }
    }

    const voiceBtnDefaultLabel = voiceBtn ? voiceBtn.textContent : 'ðŸŽ™ Speak';

    function initVoiceRecognition() {
      if (!voiceCapture.supported) {
        if (voiceBtn) voiceBtn.disabled = true;
        setVoiceStatus('Voice input not supported in this browser');
        return null;
      }
      if (voiceCapture.recognition) return voiceCapture.recognition;
      try {
        voiceCapture.recognition = new VoiceRecognitionCtor();
      } catch (err) {
        console.warn('SpeechRecognition init failed:', err);
        voiceCapture.supported = false;
        if (voiceBtn) voiceBtn.disabled = true;
        setVoiceStatus('Microphone unavailable');
        return null;
      }

      const rec = voiceCapture.recognition;
      rec.lang = 'en-US';
      rec.interimResults = true;
      rec.maxAlternatives = 1;
      rec.continuous = false;

      rec.onstart = () => {
        voiceCapture.listening = true;
        voiceCapture.finalTranscript = '';
        voiceCapture.interimTranscript = '';
        if (voiceBtn) {
          voiceBtn.textContent = 'Stop';
          voiceBtn.classList.add('live');
        }
        setVoiceStatus('Listeningâ€¦ speak now');
      };

      rec.onerror = (event) => {
        console.warn('SpeechRecognition error:', event.error);
        setVoiceStatus(`Mic error: ${event.error}`);
        voiceCapture.finalTranscript = '';
      };

      rec.onresult = (event) => {
        let finalText = voiceCapture.finalTranscript;
        let interim = '';
        for (let i = event.resultIndex; i < event.results.length; i++) {
          const result = event.results[i];
          if (result.isFinal) {
            finalText += result[0].transcript;
          } else {
            interim += result[0].transcript;
          }
        }
        voiceCapture.finalTranscript = finalText;
        voiceCapture.interimTranscript = interim;
        const combined = (finalText + ' ' + interim).trim();
        if (combined && sentenceInputEl) {
          sentenceInputEl.value = combined;
        }
      };

      rec.onend = () => {
        voiceCapture.listening = false;
        if (voiceBtn) {
          voiceBtn.textContent = voiceBtnDefaultLabel;
          voiceBtn.classList.remove('live');
        }
        if (voiceCapture.finalTranscript && voiceCapture.finalTranscript.trim()) {
          if (sentenceInputEl) {
            sentenceInputEl.value = voiceCapture.finalTranscript.trim();
          }
          setVoiceStatus('Transcribing complete');
          runSentenceConversion(sentenceInputEl ? sentenceInputEl.value : voiceCapture.finalTranscript);
        } else {
          setVoiceStatus('Mic idle');
        }
        voiceCapture.finalTranscript = '';
        voiceCapture.interimTranscript = '';
      };

      return rec;
    }

    function attachVoiceButton() {
      if (!voiceBtn) {
        setVoiceStatus('Voice control unavailable');
        return;
      }
      if (!voiceCapture.supported) {
        voiceBtn.disabled = true;
        setVoiceStatus('Voice input not supported in this browser');
        return;
      }
      setVoiceStatus('Tap mic to speak');
      voiceBtn.addEventListener('click', () => {
        const rec = initVoiceRecognition();
        if (!rec) return;
        if (voiceCapture.listening) {
          try { rec.stop(); } catch (err) { console.warn('stop failed', err); }
        } else {
          voiceCapture.finalTranscript = '';
          voiceCapture.interimTranscript = '';
          try {
            rec.start();
            setVoiceStatus('Listeningâ€¦');
          } catch (err) {
            console.warn('SpeechRecognition start failed:', err);
            setVoiceStatus('Unable to access microphone');
          }
        }
      });
    }

    // ---------- JSON normalization ----------
    function normalizeJson(json) {
      let arr = null, localFps = fps;
      if (Array.isArray(json)) {
        arr = json;
        if (window.__canonicalMeta && typeof window.__canonicalMeta.fps === 'number') {
          localFps = Number(window.__canonicalMeta.fps) || 30;
        }
      } else if (json && typeof json === 'object') {
        if (Array.isArray(json.frames)) arr = json.frames;
        if (Array.isArray(json.sequence)) arr = json.sequence;
        if (typeof json.fps === 'number') localFps = json.fps;
        if (typeof json.frame_rate === 'number') localFps = json.frame_rate;
      }
      return { arr, localFps: Math.max(1, Math.min(120, Number(localFps) || 30)) };
    }

    // ---------- Sequential Sentence Playback ----------
    async function loadWordByName(word) {
      const actualFilename = WORD_TO_FILENAME[word.toLowerCase()] || word;
      const url = `canonical/${actualFilename}_canonical_median.json`;
      try {
        const res = await fetch(url, { cache: 'no-store' });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const json = await res.json();
        return { success: true, json, word };
      } catch (e) {
        console.error(`Error loading ${word}:`, e);
        return { success: false, error: e.message, word };
      }
    }

    async function playNextWordInSentence() {
      if (!sentenceMode.active || sentenceMode.currentIndex >= sentenceMode.glosses.length) {
        // End of sentence
        if (sentenceMode.loop && sentenceMode.glosses.length > 0) {
          sentenceMode.currentIndex = 0;
          await playNextWordInSentence();
        } else {
          stopSentencePlayback();
        }
        return;
      }

      const word = sentenceMode.glosses[sentenceMode.currentIndex];
      const wordDisplay = word.toUpperCase().replace(/\b\w/g, l => l.toUpperCase());
      
      document.getElementById('sentenceProgress').textContent = 
        `Word ${sentenceMode.currentIndex + 1}/${sentenceMode.glosses.length}: ${wordDisplay}`;
      setStatus(`playing: ${wordDisplay}`);

      const result = await loadWordByName(word);
      
      if (result.success) {
        const { arr, localFps } = normalizeJson(result.json);
        if (arr && arr.length) {
          frames = arr;
          fps = localFps;
          frameIndex = 0;
          pausedAt = 0;
          
          // Play this word's real world emulation
          playing = true;
          startTime = performance.now();
          raf = requestAnimationFrame(tick);
          
          // Wait for the emulation to complete
          await waitForWordComplete(arr.length);
          
          if (sentenceMode.active) {
            sentenceMode.currentIndex++;
            await playNextWordInSentence();
          }
        } else {
          setStatus(`Error: no frames in ${word}`);
          sentenceMode.currentIndex++;
          await playNextWordInSentence();
        }
      } else {
        setStatus(`Error loading ${word}: ${result.error}`);
        sentenceMode.currentIndex++;
        await playNextWordInSentence();
      }
    }

    function waitForWordComplete(totalFrames) {
      return new Promise(resolve => {
        const checkComplete = () => {
          if (!sentenceMode.active || frameIndex >= totalFrames - 1) {
            resolve();
          } else {
            requestAnimationFrame(checkComplete);
          }
        };
        checkComplete();
      });
    }

    function startSentencePlayback(glosses) {
      if (glosses.length === 0) return;
      
      sentenceMode.active = true;
      sentenceMode.glosses = glosses;
      sentenceMode.currentIndex = 0;
      sentenceMode.loop = document.getElementById('loopSentence').checked;
      
      document.getElementById('playSentence').disabled = true;
      document.getElementById('stopSentence').disabled = false;
      
      playNextWordInSentence();
    }

    function stopSentencePlayback() {
      sentenceMode.active = false;
      sentenceMode.currentIndex = 0;
      playing = false;
      if (raf) cancelAnimationFrame(raf);
      raf = null;
      
      document.getElementById('playSentence').disabled = false;
      document.getElementById('stopSentence').disabled = true;
      document.getElementById('sentenceProgress').textContent = '';
      setStatus('sentence playback stopped');
    }

    async function loadWord() {
      const w = (wordEl.value || '').trim().toLowerCase();
      if (!w) { setStatus('error: enter a word'); return; }
      
      // Stop any sentence playback
      if (sentenceMode.active) {
        stopSentencePlayback();
      }
      
      const url = `canonical/${encodeURIComponent(w)}_canonical_median.json`;
      setStatus(`loading ${url} â€¦`);
      stop();

      try {
        const res = await fetch(url, { cache: 'no-store' });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const json = await res.json();

        const { arr, localFps } = normalizeJson(json);
        if (!arr || !arr.length) throw new Error('no frames found');

        frames = arr; fps = localFps; frameIndex = 0; pausedAt = 0;
        setStatus(`ready: ${frames.length} frames @ ${fps} fps`);
        enableControls(true);

        window.applyCanonicalFrame(frames[0], 0); // show first frame
        updateHud();
        play();                                   // auto-play so you see motion
      } catch (e) {
        frames = null; enableControls(false);
        setStatus('error: ' + (e && e.message ? e.message : 'load failed'));
        updateHud();
      }
    }

    function tick(t) {
      if (!playing || !frames || !frames.length) return;
      const msPerFrame = 1000 / fps;
      if (!startTime) startTime = t;
      const elapsed = t - startTime;
      const nextIdx = Math.floor(elapsed / msPerFrame);
      if (nextIdx !== frameIndex) frameIndex = nextIdx;

      if (frameIndex >= frames.length) {
        pause(); setStatus('done'); updateHud(); return;
      }

      try { window.applyCanonicalFrame(frames[frameIndex], frameIndex); } catch(e) { console.warn(e); }
      raf = requestAnimationFrame(tick);
      updateHud();
    }

    function play() {
      if (!frames || !frames.length) { setStatus('nothing loaded'); return; }
      playing = true; btnPlayPause.textContent = 'Pause'; setStatus('playing');
      startTime = pausedAt > 0 ? performance.now() - pausedAt * (1000 / fps) : performance.now();
      raf = requestAnimationFrame(tick); updateHud();
    }
    function pause() {
      playing = false; if (raf) cancelAnimationFrame(raf); raf = null;
      pausedAt = frameIndex; btnPlayPause.textContent = 'Play'; setStatus('paused'); updateHud();
    }
    function stop() {
      playing = false; if (raf) cancelAnimationFrame(raf); raf = null;
      frameIndex = 0; pausedAt = 0; btnPlayPause.textContent = 'Play'; updateHud();
    }
    function stepOnce() {
      if (!frames || !frames.length) return;
      pause(); frameIndex = Math.min(frameIndex + 1, frames.length - 1);
      window.applyCanonicalFrame(frames[frameIndex], frameIndex);
      setStatus('stepping'); updateHud();
    }

    // ---------- Renderer (robust + visible) ----------
    function clearCanvas() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#ffffff';               // bright background so colors pop
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    // recurse to collect ANY arrays of {x,y} or [x,y] (even nested)
    function collectPointArrays(obj, out) {
      if (!obj) return;
      if (Array.isArray(obj)) {
        if (obj.length && Array.isArray(obj[0]) && obj[0].length >= 2 && isFinite(obj[0][0]) && isFinite(obj[0][1])) {
          out.push(obj.map(p => [Number(p[0]), Number(p[1]), Number(p[2] ?? 0)])); return;
        }
        if (obj.length && typeof obj[0] === 'object' && obj[0] && 'x' in obj[0] && 'y' in obj[0]) {
          out.push(obj.map(p => [Number(p.x), Number(p.y), Number(('z' in p) ? p.z : 0)])); return;
        }
        for (const el of obj) collectPointArrays(el, out);
        return;
      }
      if (typeof obj === 'object') {
        for (const k in obj) collectPointArrays(obj[k], out);
      }
    }
    function mergePointSets(pointSets) {
      const merged = []; for (const arr of pointSets) for (const p of arr) merged.push(p); return merged;
    }
    function isNormalized(pts) {
      let hits = 0; for (let i = 0; i < Math.min(10, pts.length); i++) { const [x,y]=pts[i]; if (x>=0&&x<=1&&y>=0&&y<=1) hits++; }
      return hits >= Math.min(3, pts.length);
    }
    function computeBBox(pts) {
      let minX= Infinity, minY= Infinity, maxX=-Infinity, maxY=-Infinity;
      for (const [x,y] of pts) { if (x<minX)minX=x; if (y<minY)minY=y; if (x>maxX)maxX=x; if (y>maxY)maxY=y; }
      return {minX, minY, maxX, maxY, w:maxX-minX, h:maxY-minY};
    }

    function computeBBox3D(pts) {
      let minX= Infinity, minY= Infinity, minZ= Infinity;
      let maxX=-Infinity, maxY=-Infinity, maxZ=-Infinity;
      for (const [x, y, zRaw] of pts) {
        const z = Number.isFinite(zRaw) ? zRaw : 0;
        if (x < minX) minX = x;
        if (x > maxX) maxX = x;
        if (y < minY) minY = y;
        if (y > maxY) maxY = y;
        if (z < minZ) minZ = z;
        if (z > maxZ) maxZ = z;
      }
      return { minX, minY, minZ, maxX, maxY, maxZ, w: maxX - minX, h: maxY - minY, d: maxZ - minZ };
    }

    function withinUnitRange(bbox, epsilon = 0.01) {
      if (!bbox) return false;
      return Number.isFinite(bbox.minX) && Number.isFinite(bbox.maxX) &&
        Number.isFinite(bbox.minY) && Number.isFinite(bbox.maxY) &&
        bbox.minX >= -epsilon && bbox.maxX <= 1 + epsilon &&
        bbox.minY >= -epsilon && bbox.maxY <= 1 + epsilon;
    }

    function expandBBox(bbox, fraction = 0.08) {
      if (!bbox || !Number.isFinite(bbox.minX) || !Number.isFinite(bbox.maxX) ||
          !Number.isFinite(bbox.minY) || !Number.isFinite(bbox.maxY)) {
        return { minX: -1, maxX: 1, minY: -1, maxY: 1, w: 2, h: 2 };
      }
      const padX = Math.max(Math.abs(bbox.w) * fraction, 0.01);
      const padY = Math.max(Math.abs(bbox.h) * fraction, 0.01);
      return {
        minX: bbox.minX - padX,
        maxX: bbox.maxX + padX,
        minY: bbox.minY - padY,
        maxY: bbox.maxY + padY,
        w: (bbox.w || 0) + padX * 2,
        h: (bbox.h || 0) + padY * 2
      };
    }

    function expandBBox3D(bbox, fraction = 0.08) {
      if (!bbox || !Number.isFinite(bbox.minX) || !Number.isFinite(bbox.minY) || !Number.isFinite(bbox.minZ)) {
        return { minX: -1, maxX: 1, minY: -1, maxY: 1, minZ: -1, maxZ: 1, w: 2, h: 2, d: 2 };
      }
      const padX = Math.max(Math.abs(bbox.w) * fraction, 0.01);
      const padY = Math.max(Math.abs(bbox.h) * fraction, 0.01);
      const padZ = Math.max(Math.abs(bbox.d) * fraction, 0.01);
      return {
        minX: bbox.minX - padX,
        maxX: bbox.maxX + padX,
        minY: bbox.minY - padY,
        maxY: bbox.maxY + padY,
        minZ: bbox.minZ - padZ,
        maxZ: bbox.maxZ + padZ,
        w: (bbox.w || 0) + padX * 2,
        h: (bbox.h || 0) + padY * 2,
        d: (bbox.d || 0) + padZ * 2
      };
    }

    function drawDebugBBox(ctx, bbox) {
      if (!bbox) return;
      ctx.save();
      ctx.strokeStyle = '#22c55e';
      ctx.setLineDash([6, 4]);
      ctx.lineWidth = 2;
      ctx.strokeRect(bbox.minX, bbox.minY, Math.max(0, bbox.maxX - bbox.minX), Math.max(0, bbox.maxY - bbox.minY));
      ctx.restore();
    }

    function updateBoxExtents(box, x, y, z) {
      if (x < box.minX) box.minX = x;
      if (x > box.maxX) box.maxX = x;
      if (y < box.minY) box.minY = y;
      if (y > box.maxY) box.maxY = y;
      if (z < box.minZ) box.minZ = z;
      if (z > box.maxZ) box.maxZ = z;
    }

    function safeDim(value) {
      return Number.isFinite(value) && Math.abs(value) > 1e-5 ? Math.abs(value) : 1e-2;
    }

    function create2DTransform(bbox, PAD, W, H, flipY, autofit, padding = 0.9) {
      if (!bbox || !Number.isFinite(bbox.minX) || !Number.isFinite(bbox.maxX)) {
        return {
          map: () => [PAD, PAD],
          screenBBox: null,
          scale: 1,
          center: { x: 0, y: 0 }
        };
      }
      const safeW = safeDim(bbox.w);
      const safeH = safeDim(bbox.h);
      const scaleBase = Math.min(W / safeW, H / safeH);
      let scale = scaleBase * padding;
      if (!autofit) scale = 1;
      const cx = (bbox.minX + bbox.maxX) / 2;
      const cy = (bbox.minY + bbox.maxY) / 2;
      const originX = PAD + W / 2;
      const originY = PAD + H / 2;
      const map = (x, y) => {
        const px = (x - cx) * scale + originX;
        const signedY = (y - cy) * scale;
        const py = flipY ? originY - signedY : originY + signedY;
        return [px, py];
      };

      const corners = [
        [bbox.minX, bbox.minY],
        [bbox.maxX, bbox.minY],
        [bbox.maxX, bbox.maxY],
        [bbox.minX, bbox.maxY]
      ];
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      for (const [x, y] of corners) {
        const [px, py] = map(x, y);
        if (px < minX) minX = px;
        if (px > maxX) maxX = px;
        if (py < minY) minY = py;
        if (py > maxY) maxY = py;
      }

      return {
        map,
        screenBBox: { minX, minY, maxX, maxY },
        scale,
        center: { x: cx, y: cy }
      };
    }

    function create3DTransform(bbox, canvasW, canvasH, padding = 0.9) {
      if (!bbox || !Number.isFinite(bbox.minX)) {
        return {
          scale: 1,
          center: { x: 0, y: 0, z: 0 }
        };
      }
      const safeW = safeDim(bbox.w);
      const safeH = safeDim(bbox.h);
      const scaleBase = Math.min(canvasW / safeW, canvasH / safeH);
      const scale = scaleBase * padding;
      const center = {
        x: (bbox.minX + bbox.maxX) / 2,
        y: (bbox.minY + bbox.maxY) / 2,
        z: (bbox.minZ + bbox.maxZ) / 2
      };
      return { scale, center };
    }

    // --- minimal THREE setup ---
    let __three = null;
    function initThree(containerW=960, containerH=540) {
      const viewContainer = document.getElementById('threeView');
      if (!viewContainer) return;
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(45, containerW/containerH, 0.1, 10000);
      camera.position.set(0, 0, 450);
      camera.lookAt(0, 0, 0);

      const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(containerW, containerH);
      renderer.domElement.style.width = '100%';
      renderer.domElement.style.height = 'auto';
      let badge = viewContainer.querySelector('.viewBadge');
      if (!badge) {
        badge = document.createElement('div');
        badge.className = 'viewBadge';
        viewContainer.appendChild(badge);
      }
      viewContainer.insertBefore(renderer.domElement, badge);
      badge.textContent = '3D';

      const light = new THREE.DirectionalLight(0xffffff, 1.0);
      light.position.set(0, 0, 1);
      scene.add(light);
      scene.add(new THREE.AmbientLight(0xffffff, 0.35));

      __three = { scene, camera, renderer, points: null, lines: null, bboxHelper: null };
    }

    function resizeThreeRenderer(width, height) {
      if (!__three || !width || !height) return;
      __three.renderer.setSize(width, height);
      __three.camera.aspect = width / height;
      __three.camera.updateProjectionMatrix();
    }

    function ensureGeometries(numPoints, totalSegments) {
      if (!__three.points || __three.points.geometry.attributes.position.count !== numPoints) {
        if (__three.points) __three.scene.remove(__three.points);
        const g = new THREE.BufferGeometry();
        g.setAttribute('position', new THREE.Float32BufferAttribute(new Float32Array(numPoints * 3), 3));
        const m = new THREE.PointsMaterial({ color: 0xff1a1a, size: 6, sizeAttenuation: false });
        __three.points = new THREE.Points(g, m);
        __three.scene.add(__three.points);
      }
      const lineVerts = totalSegments * 2;
      if (!__three.lines || __three.lines.geometry.attributes.position.count !== lineVerts) {
        if (__three.lines) __three.scene.remove(__three.lines);
        const gL = new THREE.BufferGeometry();
        gL.setAttribute('position', new THREE.Float32BufferAttribute(new Float32Array(lineVerts * 3), 3));
        const mL = new THREE.LineBasicMaterial({ color: 0x00a3ff, linewidth: 2 });
        __three.lines = new THREE.LineSegments(gL, mL);
        __three.scene.add(__three.lines);
      }
    }

    // Compute extra anatomical 3D segments not present as raw landmark pairs
    function computeExtraSegments3D(pts) {
      const segments = [];
      const get = (idx) => (pts[idx] ? pts[idx] : null);
      const LS = POSE.L_SHOULDER, RS = POSE.R_SHOULDER;
      const LH = POSE.L_HIP, RH = POSE.R_HIP;
      const NOSE = POSE.NOSE;
      const pLS = get(LS), pRS = get(RS);
      const pLH = get(LH), pRH = get(RH);
      // Neck at midpoint of shoulders
      if (pLS && pRS) {
        const neck = [(pLS[0] + pRS[0]) / 2, (pLS[1] + pRS[1]) / 2, (pLS[2] + pRS[2]) / 2];
        segments.push([neck, pLS], [neck, pRS]); // neckâ†’left/right shoulder
        const pNose = get(NOSE);
        if (pNose) segments.push([pNose, neck]); // optional aesthetic noseâ†’neck
      }
      // Hip center at midpoint of hips
      if (pLH && pRH) {
        const hipC = [(pLH[0] + pRH[0]) / 2, (pLH[1] + pRH[1]) / 2, (pLH[2] + pRH[2]) / 2];
        segments.push([hipC, pLH], [hipC, pRH]); // hip centerâ†’left/right hip
      }
      return segments;
    }

    function drawEdges(edges, pts, mapper, edgeColor) {
      if (!Array.isArray(edges)) return;
      ctx.beginPath();
      for (const e of edges) {
        if (!Array.isArray(e) || e.length < 2) continue;
        const a = e[0], b = e[1];
        if (!pts[a] || !pts[b]) continue;
        const p1 = mapper(pts[a][0], pts[a][1]);
        const p2 = mapper(pts[b][0], pts[b][1]);
        ctx.moveTo(p1[0], p1[1]); ctx.lineTo(p2[0], p2[1]);
      }
      ctx.lineWidth = 3;
      ctx.strokeStyle = edgeColor;
      ctx.stroke();
    }

    function updateThreeDebugBox(box) {
      if (!__three) return;
      if (box && showBBoxEl && showBBoxEl.checked) {
        if (!__three.bboxHelper) {
          __three.bboxHelper = new THREE.Box3Helper(new THREE.Box3(), 0x22c55e);
          __three.scene.add(__three.bboxHelper);
        }
        __three.bboxHelper.box.min.set(box.minX, box.minY, box.minZ);
        __three.bboxHelper.box.max.set(box.maxX, box.maxY, box.maxZ);
        __three.bboxHelper.visible = true;
      } else if (__three && __three.bboxHelper) {
        __three.bboxHelper.visible = false;
      }
    }

    function drawEdges(edges, pts, mapper, edgeColor) {
      if (!Array.isArray(edges)) return;
      ctx.beginPath();
      for (const e of edges) {
        if (!Array.isArray(e) || e.length < 2) continue;
        const a = e[0], b = e[1];
        if (!pts[a] || !pts[b]) continue;
        const p1 = mapper(pts[a][0], pts[a][1]);
        const p2 = mapper(pts[b][0], pts[b][1]);
        ctx.moveTo(p1[0], p1[1]); ctx.lineTo(p2[0], p2[1]);
      }
      ctx.lineWidth = 3;
      ctx.strokeStyle = edgeColor;
      ctx.stroke();
    }

    window.applyCanonicalFrame = function(frame, i) {
      clearCanvas();

      // collect points (robust, nested)
      const sets = []; collectPointArrays(frame, sets);
      if (!sets.length) {
        ctx.fillStyle = '#111'; ctx.font = '14px ui-monospace, monospace';
        ctx.fillText('No 2D points detected in this frame.', 12, 22);
        if (i % 10 === 0) console.log('Frame (no 2D points)', i, frame);
        return;
      }

      // merge all sets (pose + hands, etc.)
      const pts = mergePointSets(sets);
      const { width: canvasWidth, height: canvasHeight } = syncCanvasSize();
      const PAD = 30, W = canvasWidth - PAD * 2, H = canvasHeight - PAD * 2;
      const rawBBox = computeBBox(pts);
      const renderBBox = expandBBox(rawBBox);
      const flipY = flipYEl.checked;
      const autofit = !!(autofitEl && autofitEl.checked);
      const showBBox = showBBoxEl && showBBoxEl.checked;
      const transform2D = create2DTransform(renderBBox, PAD, W, H, flipY, autofit);
      const screenBBox = showBBox ? transform2D.screenBBox : null;
      const bbox3D = expandBBox3D(computeBBox3D(pts));
      const threeTransform = create3DTransform(bbox3D, canvasWidth, canvasHeight);

      // Build skeleton edges based on number of points (MediaPipe structure)
      const edges = buildSkeletonEdges(pts.length);

      // ----- 2D canvas draw (under the 3D view) -----
      drawEdges(edges, pts, (x, y) => transform2D.map(x, y), edgeColorEl.value);
      const r2d = Number(ptSizeEl.value) || 4;
      ctx.fillStyle = ptColorEl.value;
      for (const [x, y] of pts) {
        const [px, py] = transform2D.map(x, y);
        ctx.beginPath(); ctx.arc(px, py, r2d, 0, Math.PI * 2); ctx.fill();
      }
      if (showBBox && screenBBox) {
        drawDebugBBox(ctx, screenBBox);
      }
      // ----------------------------------------------

      // 3D render path with THREE.js
      if (!__three) {
        initThree(canvasWidth, canvasHeight);
      } else {
        resizeThreeRenderer(canvasWidth, canvasHeight);
      }
      const extraSegments = computeExtraSegments3D(pts);
      ensureGeometries(pts.length, edges.length + extraSegments.length);

      const flipY3D = -1;
      const transformedPts = new Array(pts.length);
      const scaledBox = { minX: Infinity, minY: Infinity, minZ: Infinity, maxX: -Infinity, maxY: -Infinity, maxZ: -Infinity };
      const cameraExtent = Math.max(safeDim(bbox3D.w), safeDim(bbox3D.h), safeDim(bbox3D.d));
      const zoomFactorRaw = zoom3dEl ? Number(zoom3dEl.value) : 1;
      const zoomFactor = Number.isFinite(zoomFactorRaw) && zoomFactorRaw > 0 ? zoomFactorRaw : 1;
      const cameraDistanceBase = cameraExtent * threeTransform.scale * 1.2 + 250;
      const cameraDistance = cameraDistanceBase / zoomFactor;
      __three.camera.position.set(0, 0, cameraDistance);
      __three.camera.lookAt(0, 0, 0);
      __three.camera.updateProjectionMatrix();

      // update point positions
      {
        const arr = __three.points.geometry.attributes.position.array;
        for (let i = 0; i < pts.length; i++) {
          const src = pts[i];
          const tx = (src[0] - threeTransform.center.x) * threeTransform.scale;
          const ty = (src[1] - threeTransform.center.y) * threeTransform.scale * flipY3D;
          const tz = ((src[2] || 0) - threeTransform.center.z) * threeTransform.scale;
          transformedPts[i] = [tx, ty, tz];
          updateBoxExtents(scaledBox, tx, ty, tz);
          const k = i * 3;
          arr[k] = tx; arr[k+1] = ty; arr[k+2] = tz;
        }
        __three.points.geometry.attributes.position.needsUpdate = true;
      }

      // update line segments: base skeleton edges + extra anatomical segments
      {
        const arr = __three.lines.geometry.attributes.position.array;
        let k = 0;
        for (let i = 0; i < edges.length; i++) {
          const a = edges[i][0], b = edges[i][1];
          const [ax, ay, az] = transformedPts[a];
          const [bx, by, bz] = transformedPts[b];
          arr[k] = ax; arr[k+1] = ay; arr[k+2] = az; k += 3;
          arr[k] = bx; arr[k+1] = by; arr[k+2] = bz; k += 3;
        }
        for (let i = 0; i < extraSegments.length; i++) {
          const A = extraSegments[i][0], B = extraSegments[i][1];
          const ax = (A[0] - threeTransform.center.x) * threeTransform.scale;
          const ay = (A[1] - threeTransform.center.y) * threeTransform.scale * flipY3D;
          const az = ((A[2] || 0) - threeTransform.center.z) * threeTransform.scale;
          const bx = (B[0] - threeTransform.center.x) * threeTransform.scale;
          const by = (B[1] - threeTransform.center.y) * threeTransform.scale * flipY3D;
          const bz = ((B[2] || 0) - threeTransform.center.z) * threeTransform.scale;
          updateBoxExtents(scaledBox, ax, ay, az);
          updateBoxExtents(scaledBox, bx, by, bz);
          arr[k] = ax; arr[k+1] = ay; arr[k+2] = az; k += 3;
          arr[k] = bx; arr[k+1] = by; arr[k+2] = bz; k += 3;
        }
        __three.lines.geometry.attributes.position.needsUpdate = true;
      }

      if (!Number.isFinite(scaledBox.minX)) {
        updateThreeDebugBox(null);
      } else {
        updateThreeDebugBox(showBBox ? scaledBox : null);
      }

      // render the scene
      __three.renderer.render(__three.scene, __three.camera);
    };

    // ---------- events ----------
    // Sentence conversion
    if (convertBtn) {
      convertBtn.addEventListener('click', () => {
        const sentence = sentenceInputEl ? (sentenceInputEl.value || '') : '';
        runSentenceConversion(sentence);
      });
    }
    
    if (sentenceInputEl) {
      sentenceInputEl.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') runSentenceConversion(sentenceInputEl.value || '');
      });
    }
    
    // Real-time dataset preview as user types
    if (sentenceInputEl) {
      sentenceInputEl.addEventListener('input', (e) => {
      showDatasetPreview(e.target.value);
      });
    }

    document.getElementById('semanticMatches').addEventListener('change', (event) => {
      if (!event.target.classList.contains('semantic-toggle')) return;
      const idx = Number(event.target.dataset.token);
      if (!lastConversion || Number.isNaN(idx)) return;
      const token = lastConversion.tokens[idx];
      if (!token) return;
      token.accepted = event.target.checked;
      refreshConversionViews();
    });
    
    document.getElementById('playSentence').addEventListener('click', () => {
      const glosses = JSON.parse(document.getElementById('playSentence').dataset.glosses || '[]');
      startSentencePlayback(glosses);
    });
    
    document.getElementById('stopSentence').addEventListener('click', () => {
      stopSentencePlayback();
    });
    
    // Single word playback
    btnLoad.addEventListener('click', loadWord);
    btnPlayPause.addEventListener('click', () => (playing ? pause() : play()));
    btnStop.addEventListener('click', stop);
    btnStep.addEventListener('click', stepOnce);
    wordEl.addEventListener('keydown', (e) => { if (e.key === 'Enter') loadWord(); });
    window.addEventListener('keydown', (e) => {
  const active = document.activeElement;
  const isTyping = active && (active.tagName === 'INPUT' || active.tagName === 'TEXTAREA');

  // â¯ï¸ Space toggles only when not typing in a field
  if (e.key === ' ' && !isTyping) {
    e.preventDefault();
    if (!btnPlayPause.disabled) playing ? pause() : play();
  }

  // â–¶ï¸ Step with right arrow (same rule)
  if (e.key === 'ArrowRight' && !isTyping) {
    e.preventDefault();
    stepOnce();
  }
});


    if (zoom3dEl) {
      updateZoomDisplay();
      zoom3dEl.addEventListener('input', () => {
        updateZoomDisplay();
        rerenderCurrentFrame();
      });
    } else if (zoom3dValEl) {
      zoom3dValEl.textContent = '1.0x';
    }

    // live UI updates
    ptSizeEl.addEventListener('input', () => { ptSizeValEl.textContent = ptSizeEl.value; });
    ptColorEl.addEventListener('input', () => { ptSwatch.style.background = ptColorEl.value; });
    edgeColorEl.addEventListener('input', () => { edgeSwatch.style.background = edgeColorEl.value; });

    attachVoiceButton();
    setStatus('ready - enter a sentence to convert to ISL glosses'); updateHud();
    refreshConversionViews();
  </script>
</body>
</html>
